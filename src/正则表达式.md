## 正则表达式

多次遇到多次跳过的知识点！！！

```js
    // 1.字面量写法
    //   /pattern/g
    // g i m
    let p = /mjj/g
    p.test()
    // 2.构造函数写法
    let p1 = new RegExp('hello','g')
    // 区别？ 有一次面试被问两种创建方式的区别，不会... 查了一下  
    /*
        构造函数的写法传入的是字符串，'/'需要转义

        字面量：当正则表达式保持不变时，使用此方法可获得更好的性能。
        构造函数：当你知道正则表达式的模式将会改变，或者你不知道模式，并且从其他来源获取它，如用户输入。
        推荐使用字面量方式，如果是包含变量的正则，只能使用构造函数方式。
    */

    // 元字符  . 匹配任意字符
    // ^ 匹配开始字符
    // $ 匹配结束字符
    // 匹配数字和字母和下划线  \w   匹配非字符和数字和下划线 \W
    // 匹配数字       \d   匹配非数字       \D
    // 匹配空白字符   \s   除了空白字符     \S
    // 区间 [a-z] [a-zA-Z0-9] [\u4e00-u9fa5] 中文
    // [^\u4e00-u9fa5]  范围之外  
    // + 匹配一次或多次
    // [mM] 大写或小写
    // [] 或的关系
    // * 匹配零次或者多次字符
    // ？匹配零次或多次
    // {2} 个数  {1,9} 1-9次
    // () 分组匹配  $1 捕获分组
    // | 或者
    // (?:)  不捕获
    // 捕获方法 RegExp.$1

    // 正向预查 （？=） 包含但不匹配 （？1） 否定预查  不包含不匹配
    // 反向预查  （？<=） (?<!)
    // {4,8}  最少4位，最多8位

    // test() 返回一个布尔值  表示能否匹配到字符串
    // exec() 返回匹配的结果，发现匹配值，就返回一个数组，数组中的成员都是匹配的字符串 否则返回null

    // 字符串方法
    // match() 和exec() 相似
    // search() 返回第一个满足匹配条件字符串的位置，没有则返回-1
    // replace()  两个参数 正则表达式  要替换的字符

    // 检查用户账号
    /*
      验证规则：由字母，数字，下划线组成，以祖母开头，4-16位
      let reg = /^[a-zA-Z]/w{3,15}$/g
    */
    // 匹配手机号
    /*
      验证规则：11位  1开头 13 15 17 18  
      let reg = /^1[3|5|7|8]\d{9}/g 
    */
    // 匹配电话号码
    /*
      验证规则  区号 + 号码
      let reg = /^0\d{2,30}-?\d{7,8}$/g
    */

    //匹配身份证号
    /*
      验证规则 18 或 15 位， 15位的全部是数字  18位的前17位是数字  最后一位可能是x或数字
    let reg = /^(\d{15}$)|(^\d{18}$)|(^\d{17}(\d|x|X)$)/g
    */

    // 匹配邮箱 
    /*
      验证规则   第一部分@第二部分.com|cn|net
      let reg = /^[a-zA-Z0-9-._]+[@][a-zA-Z0-9-._]+\.(com|cn|net)/g
    */
```

